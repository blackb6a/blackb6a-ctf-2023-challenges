from Crypto.Util.number import long_to_bytes
from pwn import process

load('AGCD.sage')

r = process('python3 ../public/chall-easy.py', shell=True)
N = int(r.recvline().decode().split(' = ')[1])
e = int(r.recvline().decode().split(' = ')[1])
l_dp = int(r.recvline().decode().split(' = ')[1])
l_dq = int(r.recvline().decode().split(' = ')[1])
ct = int(r.recvline().decode().split(' = ')[1])
print(f'{N = }')
print(f'{e = }')
print(f'{l_dp = }')
print(f'{l_dq = }')
print(f'{ct = }')


def recover(N, e, l_dp, l_dq, alpha, mask_bit, m1=7, m2=40):
    N, e, l_dp, l_dq = map(ZZ, [N, e, l_dp, l_dq])
    bits = N.nbits()
    mask = 2 ^ mask_bit

    A = -(e ^ 2 * l_dp * l_dq - e * (l_dp + l_dq) + 1)
    B = gcd(N - 1, e * mask)
    C = ZZ(Mod((N - 1) // B, e * mask) ^ -1)

    x, y = PolynomialRing(QQ, 'x, y').gens()
    X = Y = floor(N ^ alpha)

    f = B * x * y - C * (e * l_dq - 1) * x - C * (e * l_dp - 1) * y + A * C

    monomials = [x ^ a * y ^ b for a in range(m1 + 1) for b in range(m1 + 1)]

    matB = Matrix(ZZ, (m1 + 1) ^ 2)

    matB[0, 0] = (e * mask) ^ m1
    for j in range(1, (m1 + 1) ^ 2):
        a, b = divmod(j, m1 + 1)
        if a >= b:
            g = x ^ (a - b) * f ^ b * (e * mask) ^ (m1 - b)
        else:
            g = y ^ (b - a) * f ^ a * (e * mask) ^ (m1 - a)
        g = g(x=x * X, y=y * Y)

        for i, mon in enumerate(monomials):
            matB[j, i] = g.coefficient(mon)(x=0, y=0)

    print(f"[1] Starting LLL of {(m1 + 1)^2} x {(m1 + 1)^2} matrix")
    matB = matB.LLL()

    ep = next_prime(e)
    emod = PolynomialRing(GF(ep), 2, 'x, y')

    polys = []
    for j in range((m1 + 1) ^ 2):
        f = 0
        for i, mon in enumerate(monomials):
            f += ZZ(matB[j, i] / mon(x=X, y=Y)) * mon
        polys.append(emod(f))

    for j in range(len(polys), 0, -1):
        B = Ideal(polys[:j]).groebner_basis()
        if len(B) == 0:
            break

        if B[0] != 1:
            break

    if len(B) >= 2:
        k, l = ZZ(ep - B[0](0, 0)), ZZ(ep - B[1](0, 0))
    else:
        print("[1] Stage 1 failed...")
        exit(1)

    print(f"[1] Recovered k, l = ({k}, {l})")

    a = ZZ((e * l_dp + k - 1) * pow(e * mask, -1, k * N))

    h_dp = find_roots(a, k, N, 1 / 2, alpha, bits // 2 - mask_bit, m=m2)
    dp = h_dp * mask + l_dp

    p = ZZ((e * dp - 1) // k + 1)

    assert p > 0 and N % p == 0

    return p, N // p


def main():
    bits = 1024
    given = bits // 5
    alpha = 1 / 12

    assert N.bit_length() == bits

    _p, _q = recover(N, e, l_dp, l_dq, alpha, given, 7, 14)
    assert _p * _q == N

    print("[+] Recovered!")
    print(f'[+] {_p = }')
    print(f'[+] {_q = }')

    l = (_p - 1) * (_q - 1)
    d = ZZ(pow(e, -1, l))
    print('[*]', long_to_bytes(ZZ(pow(ct, d, N))).decode())

    return


if __name__ == '__main__':
    main()
