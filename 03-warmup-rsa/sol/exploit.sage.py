

# This file was *autogenerated* from the file exploit.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_7 = Integer(7); _sage_const_40 = Integer(40); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1024 = Integer(1024); _sage_const_5 = Integer(5); _sage_const_12 = Integer(12); _sage_const_14 = Integer(14)
from Crypto.Util.number import long_to_bytes
from pwn import process

load('AGCD.sage')

r = process('python3 ../public/chall-easy.py', shell=True)
N = int(r.recvline().decode().split(' = ')[_sage_const_1 ])
e = int(r.recvline().decode().split(' = ')[_sage_const_1 ])
l_dp = int(r.recvline().decode().split(' = ')[_sage_const_1 ])
l_dq = int(r.recvline().decode().split(' = ')[_sage_const_1 ])
ct = int(r.recvline().decode().split(' = ')[_sage_const_1 ])
print(f'{N = }')
print(f'{e = }')
print(f'{l_dp = }')
print(f'{l_dq = }')
print(f'{ct = }')


def recover(N, e, l_dp, l_dq, alpha, mask_bit, m1=_sage_const_7 , m2=_sage_const_40 ):
    N, e, l_dp, l_dq = map(ZZ, [N, e, l_dp, l_dq])
    bits = N.nbits()
    mask = _sage_const_2  ** mask_bit

    A = -(e ** _sage_const_2  * l_dp * l_dq - e * (l_dp + l_dq) + _sage_const_1 )
    B = gcd(N - _sage_const_1 , e * mask)
    C = ZZ(Mod((N - _sage_const_1 ) // B, e * mask) ** -_sage_const_1 )

    x, y = PolynomialRing(QQ, 'x, y').gens()
    X = Y = floor(N ** alpha)

    f = B * x * y - C * (e * l_dq - _sage_const_1 ) * x - C * (e * l_dp - _sage_const_1 ) * y + A * C

    monomials = [x ** a * y ** b for a in range(m1 + _sage_const_1 ) for b in range(m1 + _sage_const_1 )]

    matB = Matrix(ZZ, (m1 + _sage_const_1 ) ** _sage_const_2 )

    matB[_sage_const_0 , _sage_const_0 ] = (e * mask) ** m1
    for j in range(_sage_const_1 , (m1 + _sage_const_1 ) ** _sage_const_2 ):
        a, b = divmod(j, m1 + _sage_const_1 )
        if a >= b:
            g = x ** (a - b) * f ** b * (e * mask) ** (m1 - b)
        else:
            g = y ** (b - a) * f ** a * (e * mask) ** (m1 - a)
        g = g(x=x * X, y=y * Y)

        for i, mon in enumerate(monomials):
            matB[j, i] = g.coefficient(mon)(x=_sage_const_0 , y=_sage_const_0 )

    print(f"[1] Starting LLL of {(m1 + _sage_const_1 )**_sage_const_2 } x {(m1 + _sage_const_1 )**_sage_const_2 } matrix")
    matB = matB.LLL()

    ep = next_prime(e)
    emod = PolynomialRing(GF(ep), _sage_const_2 , 'x, y')

    polys = []
    for j in range((m1 + _sage_const_1 ) ** _sage_const_2 ):
        f = _sage_const_0 
        for i, mon in enumerate(monomials):
            f += ZZ(matB[j, i] / mon(x=X, y=Y)) * mon
        polys.append(emod(f))

    for j in range(len(polys), _sage_const_0 , -_sage_const_1 ):
        B = Ideal(polys[:j]).groebner_basis()
        if len(B) == _sage_const_0 :
            break

        if B[_sage_const_0 ] != _sage_const_1 :
            break

    if len(B) >= _sage_const_2 :
        k, l = ZZ(ep - B[_sage_const_0 ](_sage_const_0 , _sage_const_0 )), ZZ(ep - B[_sage_const_1 ](_sage_const_0 , _sage_const_0 ))
    else:
        print("[1] Stage 1 failed...")
        exit(_sage_const_1 )

    print(f"[1] Recovered k, l = ({k}, {l})")

    a = ZZ((e * l_dp + k - _sage_const_1 ) * pow(e * mask, -_sage_const_1 , k * N))

    h_dp = find_roots(a, k, N, _sage_const_1  / _sage_const_2 , alpha, bits // _sage_const_2  - mask_bit, m=m2)
    dp = h_dp * mask + l_dp

    p = ZZ((e * dp - _sage_const_1 ) // k + _sage_const_1 )

    assert p > _sage_const_0  and N % p == _sage_const_0 

    return p, N // p


def main():
    bits = _sage_const_1024 
    given = bits // _sage_const_5 
    alpha = _sage_const_1  / _sage_const_12 

    assert N.bit_length() == bits

    _p, _q = recover(N, e, l_dp, l_dq, alpha, given, _sage_const_7 , _sage_const_14 )
    assert _p * _q == N

    print("[+] Recovered!")
    print(f'[+] {_p = }')
    print(f'[+] {_q = }')

    l = (_p - _sage_const_1 ) * (_q - _sage_const_1 )
    d = ZZ(pow(e, -_sage_const_1 , l))
    print('[*]', long_to_bytes(ZZ(pow(ct, d, N))).decode())

    return


if __name__ == '__main__':
    main()

