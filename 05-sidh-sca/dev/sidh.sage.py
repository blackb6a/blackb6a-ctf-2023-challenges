

# This file was *autogenerated* from the file sidh.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_91 = Integer(91); _sage_const_3 = Integer(3); _sage_const_57 = Integer(57); _sage_const_6 = Integer(6)
def diff_add(P, Q, D):
    # assumes D = P - Q
    # returns P + Q, [2]P
    if Q == (_sage_const_1 , _sage_const_0 ):
        raise RuntimeError("Zero Point Attack detected!!!")

    (x1, z1), (x2, z2), (x3, z3) = P, Q, D
    x_add = z3 * (x1 * x2 - z1 * z2) ** _sage_const_2 
    z_add = x3 * (x1 * z2 - z1 * x2) ** _sage_const_2 
    x_mul = (x1 ** _sage_const_2  - z1 ** _sage_const_2 ) ** _sage_const_2 
    z_mul = _sage_const_4  * x1 * z1 * (x1 ** _sage_const_2  + a * x1 * z1 + z1 ** _sage_const_2 )
    return (x_add, z_add), (x_mul, z_mul)


def add_mul(P, Q, R, k):
    # assumes R = Q - P
    # returns P + [k]Q
    A, B, C = Q, Q, P
    C, B = diff_add(B, C, R)

    for d in reversed(ZZ(k).digits(_sage_const_2 )[:-_sage_const_1 ]):
        if d == _sage_const_0 :
            # A, B, C -> 2A, A + B, A + C
            B, _ = diff_add(A, B, Q)
            C, A = diff_add(A, C, P)
        else:
            # A, B, C -> A + B, 2B, B + C
            A, _ = diff_add(B, A, Q)
            C, B = diff_add(B, C, R)

    return C


def test_add_mul(k):
    # assumes R = Q - P
    # returns P + [k]Q
    P, Q = var('P'), var('Q')
    R = Q - P
    A, B, C = _sage_const_0 , Q, P

    def tmp(P, Q, D):
        assert (P - Q - D) * (Q - P - D) == _sage_const_0 
        print(f'[{k}] add({P}, {Q})')
        return P + Q, _sage_const_2  * P

    A, _ = tmp(B, A, Q)
    C, B = tmp(B, C, R)

    for d in reversed(ZZ(k).digits(_sage_const_2 )[:-_sage_const_1 ]):
        if d == _sage_const_0 :
            # A, B, C -> 2A, A + B, A + C
            B, _ = tmp(A, B, Q)
            C, A = tmp(A, C, P)
        else:
            # A, B, C -> A + B, 2B, B + C
            A, _ = tmp(B, A, Q)
            C, B = tmp(B, C, R)

    return C


def point_to_xz(P):
    return (P[_sage_const_0 ], _sage_const_1 )


def xz_to_point(P):
    return E0.lift_x(P[_sage_const_0 ] / P[_sage_const_1 ])


# $IKEp182 parameters, public
lA, eA = _sage_const_2 , _sage_const_91 
lB, eB = _sage_const_3 , _sage_const_57 
p = lA ** eA * lB ** eB - _sage_const_1 

F = GF(p ** _sage_const_2 , modulus=x ** _sage_const_2  + _sage_const_1 , name='z')
z = F.gen(_sage_const_0 )

# y^2 = x^3 + 6x^2 + x
a, b = _sage_const_6 , _sage_const_1 
E0 = EllipticCurve(F, [_sage_const_0 , a, _sage_const_0 , b, _sage_const_0 ])
E0.set_order((p + _sage_const_1 ) ** _sage_const_2 , num_checks=_sage_const_0 )

# constant time
PA, QA = (lB ** eB * G for G in E0.gens())
PB, QB = (lA ** eA * G for G in E0.gens())
DA, DB = QA - PA, QB - PB

PA, QA, DA = map(point_to_xz, [PA, QA, DA])
PB, QB, DB = map(point_to_xz, [PB, QB, DB])

# Alice
privA = randrange(lA ** eA)

test_add_mul(privA)

KA = xz_to_point(add_mul(PA, QA, DA, privA))

# Bob
privB = randrange(lB ** eB)
KB = xz_to_point(add_mul(PB, QB, DB, privB))

print(hash(KA))
print(hash(KB))

