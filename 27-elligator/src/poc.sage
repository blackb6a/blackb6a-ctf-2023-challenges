# The challenge involves three hash functions: EHasherHellman, CHasherLorenz and
# CHasherPanny. EHasherHellman is just the Elligator hash-to-curve function,
# which isn't actually a cryptographic hash function - finding preimages is easy
# (the correct way is to hash the message). Next, CHasherMystiz is the CSIDH-512
# scheme where hash(m) = E / prod(l_i^m_i), m_i being the bits of m and l_i
# being the Elkies primes in F_p, p = 4l_1l_2...l_k - 1. *Class*ical results
# show that Cl(sqrt(-p)) acts on supersingular curves E, and is generated by the
# prime ideals <l_i, pi - 1> and <l_i, pi + 1>, with pi = sqrt(-p). In the
# CSI-FiSh paper, they computed the group structure of Cl(sqrt(-p)) explicitly,
# which is cyclic, and computed discrete logarithm of prime ideals (of small
# norm) w.r.t. a generator <3, pi - 1>. With this lattice, one can forge
# signatures easily. CHasherGrhkm is the same idea but with a "custom" factor
# basis l_i, forcing the player to compute the discrete logarithms themselves.

# Verify pre-image attack on EHasherHellman
print("#" * 80)
print("Testing attacks on EHasherHellman...")

load("ehasher.sage")
load("ehasher_attack.sage")

r = GF(EHasherHellman.p).random_element()
target = EHasherHellman.hash(r)
r1, r2 = elligator_attack(EHasherHellman.E.lift_x(target))
h1, h2 = map(EHasherHellman.hash, [r1, r2])
print(f"Target: {target}")
print(f"{r1 = } => hash(r1) = {h1}")
print(f"{r2 = } => hash(r2) = {h2}")
assert h1 == h2 == target

# Verify collision attack on CHasherLorenz (CSIDH-512)
print("#" * 80)
print("Testing attacks on CHasherLorenz...")

load("chasher.sage")
load("chasher_attack.sage")

n = len(csidh_512_dlog_list)
priv = [randint(-10, 11) for _ in range(n)]
priv_col = lorenz_collider(priv)
print("priv     =>", h1 := CHasherLorenz.action(0, priv))
print("priv_col =>", h2 := CHasherLorenz.action(0, priv_col))
assert h1 == h2

# Verify attack on CHasherPanny (custom CSIDH)
print("#" * 80)
print("Testing attacks on CHasherPanny...")
